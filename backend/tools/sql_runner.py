"""
SQL Runner - Simple execution engine for LLM-generated SQL
The SQL generation is handled by LLM agents, this just executes safely
"""

import asyncio
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class QueryValidationResult:
    is_valid: bool
    error_message: Optional[str] = None
    warnings: List[str] = None

@dataclass
class QueryExecutionResult:
    success: bool
    data: List[Dict[str, Any]] = None
    columns: List[str] = None
    execution_time: float = 0.0
    row_count: int = 0
    error_message: Optional[str] = None
    job_id: Optional[str] = None

class SQLRunner:
    """
    Simple SQL Runner for executing LLM-generated SQL queries
    
    The SQL generation logic is handled by LLM agents that use:
    - User intent analysis 
    - Stable schema information
    - Column-level metadata
    - Join relationships
    
    This class only handles safe execution of the generated SQL.
    """
    
    def __init__(self):
        self.db_adapter = None

    async def execute_query(self, 
                          sql: str, 
                          user_id: str = "default_user",
                          **kwargs) -> QueryExecutionResult:
        """
        Execute LLM-generated SQL query safely
        
        Args:
            sql: SQL query generated by LLM agents
            user_id: User identifier
            
        Returns:
            QueryExecutionResult with data and metadata
        """
        start_time = time.time()
        
        try:
            # Initialize database adapter if needed
            if not self.db_adapter:
                from backend.db.engine import get_adapter
                self.db_adapter = get_adapter()
            
            # Execute the SQL query
            result = self.db_adapter.run(sql, dry_run=False)
            
            execution_time = time.time() - start_time
            
            if result.error:
                return QueryExecutionResult(
                    success=False,
                    error_message=result.error,
                    execution_time=execution_time
                )
            
            # Convert rows to list of dictionaries
            data = []
            if result.rows and result.columns:
                for row in result.rows:
                    row_dict = dict(zip(result.columns, row))
                    data.append(row_dict)
            
            return QueryExecutionResult(
                success=True,
                data=data,
                columns=result.columns or [],
                execution_time=execution_time,
                row_count=len(data) if data else 0
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            return QueryExecutionResult(
                success=False,
                error_message=str(e),
                execution_time=execution_time
            )

    async def validate_query(self, sql: str, user_id: str = "default_user") -> QueryValidationResult:
        """
        Basic SQL validation (syntax only)
        The actual SQL generation logic with intent and schema is handled by LLM agents
        """
        try:
            # Basic syntax check using sqlparse if available
            try:
                import sqlparse
                parsed = sqlparse.parse(sql)
                if not parsed:
                    return QueryValidationResult(
                        is_valid=False,
                        error_message="Invalid SQL syntax"
                    )
                    
                # Check for obviously dangerous patterns
                sql_upper = sql.upper()
                dangerous_patterns = ["DROP TABLE", "DELETE FROM", "TRUNCATE", "ALTER TABLE"]
                for pattern in dangerous_patterns:
                    if pattern in sql_upper:
                        return QueryValidationResult(
                            is_valid=False,
                            error_message=f"Dangerous SQL pattern detected: {pattern}"
                        )
                        
                return QueryValidationResult(is_valid=True)
                
            except ImportError:
                # If sqlparse not available, just do basic checks
                if not sql.strip():
                    return QueryValidationResult(
                        is_valid=False,
                        error_message="Empty SQL query"
                    )
                return QueryValidationResult(is_valid=True)
                
        except Exception as e:
            return QueryValidationResult(
                is_valid=False,
                error_message=f"Validation error: {str(e)}"
            )
